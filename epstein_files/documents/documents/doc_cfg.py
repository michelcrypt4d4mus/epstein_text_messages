import json
import re
from copy import deepcopy
from dataclasses import asdict, dataclass, field, fields
from datetime import datetime
from typing import Generator, Literal, Self

from dateutil.parser import parse
from rich.text import Text

from epstein_files.util.constant.names import *
from epstein_files.util.constant.strings import *
from epstein_files.util.env import args
from epstein_files.util.helpers.data_helpers import without_falsey
from epstein_files.util.helpers.file_helper import is_doj_file
from epstein_files.util.helpers.string_helper import join_truthy, quote

DuplicateType = Literal['bounced', 'earlier', 'quoted', 'redacted', 'same']
Metadata = dict[str, bool | datetime | int | str | list[str | None] |dict[str, bool | str]]

FALSEABLE_PROPS = ['is_interesting']
MAX_LINE_LENGTH = 135
SAME = 'same'
ZUBAIR_AND_ANYA = f"{ZUBAIR_KHAN} and Anya Rasulova"

# These category names correspond to OTHER_FILES_[CATEGORY] vars in constants.py
INTERESTING_CATEGORIES = [
    CRYPTO,
    LETTER,
    MONEY,
    REPUTATION,
    RESUME,
    TEXT_MSG,
]

NEUTRAL_CATEGORIES = [
    FINANCE,
    LEGAL,
    MISC,
]

UNINTERESTING_CATEGORIES = [
    ACADEMIA,
    ARTICLE,
    ARTS,
    BOOK,
    CONFERENCE,
    JUNK,
    POLITICS,
    PROPERTY,
    SOCIAL,
]

CATEGORIES_THAT_ARE_NOT_VARNAME_SUFFIXES = [
    PRESS_RELEASE,
    SKYPE_LOG,
]

# Authors of financial report pablum
FINANCIAL_REPORTS_AUTHORS = [
    BOFA_MERRILL,
    DEUTSCHE_BANK,
    ELECTRON_CAPITAL_PARTNERS,
    GOLDMAN_INVESTMENT_MGMT,
    INSIGHTS_POD,
    'Invesco',
    JP_MORGAN,
    'Morgan Stanley',
    'S&P',
]

INTERESTING_AUTHORS = [
    EDWARD_JAY_EPSTEIN,
    EHUD_BARAK,
    JOI_ITO,
    # NOAM_CHOMSKY,
    MICHAEL_WOLFF,
    SVETLANA_POZHIDAEVA,
]

UNINTERESTING_AUTHORS = [
    GORDON_GETTY,
    NOBEL_CHARITABLE_TRUST,
    PALM_BEACH_CODE_ENFORCEMENT,
    PALM_BEACH_WATER_COMMITTEE,
    UN_GENERAL_ASSEMBLY,
]

# Description prefixes we are uninterested in
UNINTERESTING_PREFIXES = [
    'article about',
    CVRA,
    f"{HARVARD} Econ",
    HARVARD_POETRY,
    JASTA,
    LEXIS_NEXIS,
    PALM_BEACH_TSV,
    'US Office',
]

DUPE_TYPE_STRS: dict[DuplicateType, str] = {
    'bounced': 'a bounced copy of',
    'earlier': 'an earlier draft of',
    'quoted': 'quoted in full in',
    'redacted': 'a redacted version of',
    SAME: 'the same as',
}

# only used to order fields in metadtaa and repr()
FIELD_SORT_KEY = {
    'id': 'a',
    'author': 'aa',
    'comment': 'zz',
    'duplicate_ids': 'dup',
    'duplicate_of_id': 'dupe',
    'recipients': 'aaa',
}

# Fields like timestamp and author are better added from the Document object
NON_METADATA_FIELDS = [
    'actual_text',
    'id',
    'is_synthetic',
    'replace_text_with',
]

# Categories where we want to include the category name at start of the description string
CATEGORY_PREAMBLES = {
    BOOK: 'book titled',
    LETTER: 'letter',
    PRESS_RELEASE: PRESS_RELEASE,
    REPUTATION: REPUTATION_MGMT,
    RESUME: 'professional resumÃ©',
    SKYPE_LOG: SKYPE_LOG,
    TWEET: TWEET.title(),
}


@dataclass(kw_only=True)
class DocCfg:
    """
    Encapsulates info about files that needs to be manually configured because it cannot be programmatically inferred.

    Attributes:
        id (str): ID of file
        attached_to_email_id (str, optional): ID of `Email` object this document was an attachment of
        author (Name): Author of the document (if any)
        author_reason (str, optional): Optional explanation of why we are sure this email can be attributed to this author
        author_uncertain(str | bool, optional): Like setting `author_reason` but `is_attribution_uncertain` will be False
        category (str, optional): Type of file
        date (str | None): Parsed to a datetime by timestamp() if it exists
        dupe_type (DuplicateType | None): The type of duplicate this file is or its 'duplicate_ids' are
        duplicate_ids (list[str]): IDs of *other* documents that are dupes of this document
        duplicate_of_id (str | None): If this is a dupe the ID of the duplicated file. This file will be suppressed
        is_interesting (bool | None): Override other considerations and always consider this file interesting (or not)
        is_synthetic (bool): True if this config was generated by the duplicate_cfgs() method
        replace_text_with (bool): True if `description` should replace body of the document when printing.
        truncate_to (int, optional): Number of characters to truncate this email to when displayed.
    """
    id: str
    attached_to_email_id: str | None = None
    author: Name = None
    author_reason: str = ''
    author_uncertain: bool | str = ''
    category: str = ''
    comment: str = ''
    date: str = ''
    description: str = ''
    dupe_type: DuplicateType | None = None
    duplicate_ids: list[str] = field(default_factory=list)
    duplicate_of_id: str | None = None
    is_interesting: bool | None = None
    is_synthetic: bool = False
    replace_text_with: str = ''
    truncate_to: int | None = None

    @property
    def author_str(self) -> str:
        return self.author or ''

    @property
    def category_txt(self) -> Text:
        """Returns '???' for missing category."""
        from epstein_files.output.highlight_config import styled_category
        return styled_category(self.category)

    @property
    def complete_description(self) -> str:
        """String that summarizes what is known about this document."""
        # Set preamble to category if there's no author or description or CATEGORY_PREAMBLES entry
        preamble = CATEGORY_PREAMBLES.get(self.category) or ('' if self.has_any_info else self.category)
        preamble_separator = ''
        author_separator = ''
        description = ''

        if not (preamble or self.has_any_info):
            preamble = self.category

        # If description is set it must be fully constructed
        if self.category == BOOK or (self.category == ACADEMIA and self.author and self.description):
            description = join_truthy(self.description, self.author, ' by ')  # note reversed args
            description = join_truthy(preamble, description)
        elif self.category == FINANCE and self.is_description_a_title:
            author_separator = ' report: '
        elif self.category == LETTER:
            description = join_truthy(preamble, self.author, ' from ')
            description = join_truthy(description, self.recipients_str, ' to ')
            description = join_truthy(description, self.description)
        elif self.category == PRESS_RELEASE:
            description = join_truthy(preamble, self.description, ' announcing ')  # note reversed args
            description = join_truthy(self.author, description)
        elif self.category == REPUTATION or (self.category == LEGAL and 'v.' in self.author_str):
            author_separator = ': '
        elif self.category in [RESUME, TWEET]:
            preamble_separator = 'of' if self.category == RESUME else 'by'
            preamble_separator = preamble_separator.center(3, ' ')
        elif self.category == SKYPE_LOG:
            preamble_separator = ' of conversation with '

        # Construct standard description from pieces if a custom one has not been created yet
        if not description:
            preamble_author = join_truthy(preamble, self.author, preamble_separator)
            author_description = join_truthy(self.author, self.description, author_separator)

            if self.author and preamble_author.endswith(self.author) and author_description.startswith(self.author):
                preamble_author = preamble_author.removesuffix(self.author).strip()

            description = join_truthy(preamble_author, author_description)

        if self.author == INSIGHTS_POD:
            description = join_truthy(description, f"from {ZUBAIR_AND_ANYA}")

        if self.attached_to_email_id:
            description = join_truthy(description, f"attached to email {self.attached_to_email_id}", sep=', ')

        return description

    @property
    def has_any_info(self) -> bool:
        """True if either author or description is set."""
        return bool(self.description or self.author)

    @property
    def is_attribution_uncertain(self) -> bool:
        return bool(self.author_uncertain)

    @property
    def is_description_a_title(self) -> bool:
        """True if first char is uppercase or a quote."""
        if not (self.author and self.description):
            return False
        elif self.category not in [ACADEMIA, BOOK, FINANCE]:
            return False
        elif self.category == FINANCE and self.author not in FINANCIAL_REPORTS_AUTHORS:
            return False

        first_char = self.description[0]
        return first_char.isupper() or first_char in ["'", '"']

    @property
    def is_doj_file(self) -> bool:
        return is_doj_file(self.id)

    @property
    def is_house_file(self) -> bool:
        return not self.is_doj_file

    @property
    def is_of_interest(self) -> bool | None:
        """
        Self.is_interesting` value takes precedence. After that check rules below.
        Defaults to True for HOUSE_OVERSIGHT files w/out info, None for DOJ files.
        Returns None (not False) if there's no firm decision, leaving `Document` classes
        to do any other checks they might want to.

                [+] = interesting  /  - = uninteresting

            [+] INTERESTING_CATEGORIES
            [+] INTERESTING_AUTHORS
            [+] having no author/description *if* HOUSE_OVERSIGHT
             -  duplicates
             -  descriptions with UNINTERESTING_PREFIXES
             -  UNINTERESTING_CATEGORIES
             -  finance category with any author
        """
        if self.duplicate_of_id:
            return False
        elif self.is_interesting is not None:
            return self.is_interesting

        # author field check
        if self.author in INTERESTING_AUTHORS:
            return True
        # category field checks
        elif self.category in INTERESTING_CATEGORIES:
            return True
        elif self.category == FINANCE and self.author is not None:
            return False
        elif self.category in UNINTERESTING_CATEGORIES:
            return False
        # description field checks
        elif any (self.description.startswith(pfx) for pfx in UNINTERESTING_PREFIXES):
            return False

        # HOUSE_OVERSIGHT files default True, DOJ files default False or None
        if self.is_house_file:
            return True
        elif self.has_any_info:
            return True
        else:
            return None

    @property
    def metadata(self) -> Metadata:
        metadata = {k: v for k, v in asdict(self).items() if k not in NON_METADATA_FIELDS and v}

        if self.is_interesting is False:
            metadata['is_interesting'] = False

        return metadata

    @property
    def important_props(self) -> dict[str, str | None | bool]:
        props = {k: v for k, v in asdict(self).items() if v or (k in FALSEABLE_PROPS and v is False)}

        if self.is_of_interest is not None:
            if self.is_of_interest == props.get('is_interesting'):
                props['is_of_interest'] = props.pop('is_interesting')  # Remove is_intersting, just keep is_of_interest
            else:
                props['is_of_interest'] = self.is_of_interest

        if self.complete_description:
            description_pieces = without_falsey([self.author, self.description])

            # Avoid showing complete_description if it's just the author or description and other prop doesn't exist
            if len(description_pieces) != 1 or description_pieces[0] != self.complete_description:
                props['cfg.complete_description'] = self.complete_description

        if (category_txt := self.category_txt):
            if category_txt.plain == props.get('category'):
                props.pop('category')  # Leave only the colored version of category_txt

            # Only add ??? for non-email, non immesage
            if category_txt.plain == QUESTION_MARKS:
                if not isinstance(self, CommunicationCfg):
                    props['cfg.category_txt'] = category_txt
            else:
                props['cfg.category_txt'] = category_txt

        # Remove duplicated / copied field
        if (author_uncertain := props.get('author_uncertain')) and author_uncertain == props.get('author_reason'):
            props.pop('author_reason')

        if self.timestamp:
            props['timestamp'] = self.timestamp

            if 'date' in props:
                props.pop('date')

        if props.get('dupe_type') == SAME:
            props.pop('dupe_type')

        return props

    @property
    def recipients_str(self) -> str:
        """Overloaded in subclasses that support recipients."""
        return ''

    @property
    def timestamp(self) -> datetime | None:
        if self.date:
            return parse(self.date)

    def __post_init__(self):
        self.set_category(self.category)

        if self.author_uncertain and isinstance(self.author_uncertain, str):
            self.author_reason = self.author_uncertain  # Copy field

        if self.duplicate_of_id or self.duplicate_ids:
            self.dupe_type = self.dupe_type or SAME

    def duplicate_cfgs(self) -> Generator[Self, None, None]:
        """Create synthetic `DocCfg` objects that set the 'duplicate_of_id' field to point back to this object."""
        for id in self.duplicate_ids:
            dupe_cfg = deepcopy(self)
            dupe_cfg.id = id
            dupe_cfg.duplicate_ids = []
            dupe_cfg.duplicate_of_id = self.id
            dupe_cfg.dupe_type = self.dupe_type
            dupe_cfg.is_synthetic = True
            yield dupe_cfg

    def set_category(self, category: str) -> None:
        """Update the title if we changed to a category that allows titling (books, academia, finance)."""
        self.category = category.lower()
        self.description = quote(self.description) if self.is_description_a_title else self.description

    def _props_strs(self) -> list[str]:
        props = []
        add_prop = lambda f, value: props.append(f"{f.name}={value}")

        for _field in sorted(fields(self), key=lambda f: FIELD_SORT_KEY.get(f.name, f.name)):
            value = getattr(self, _field.name)

            if _field.name in ['actual_text', 'is_fwded_article', 'is_interesting']:  # fields can be False or None or ''
                if value is not None:
                    add_prop(_field, json.dumps(value))
            elif not value or _field.name == 'dupe_type' and value == 'same':
                continue
            elif _field.name == AUTHOR:
                add_prop(_field, constantize_name(str(value)) if args.constantize else f"'{value}'")
            elif _field.name == 'recipients':
                recipients_str = str([constantize_name(r) if (args.constantize and r) else r for r in value])
                add_prop(_field, recipients_str.replace("'", '') if args.constantize else recipients_str)
            elif isinstance(value, str):
                if "'" in value:
                    value = '"' + value.replace('"', r'\"') + '"'
                else:
                    value = "'" + value.replace("'", r'\'') + "'"

                add_prop(_field, value)
            else:
                add_prop(_field, str(value))

        return props

    def __rich__(self) -> Text:
        return Text(', ').join([Text(p) for p in self._props_strs()])

    def __repr__(self) -> str:
        props = self._props_strs()
        type_str = f"{type(self).__name__}("
        single_line_repr = type_str + ', '.join(props) + f')'

        if len(single_line_repr) < MAX_LINE_LENGTH or (self.comment and 'is_fwded_article' in dir(self) and getattr(self, 'is_fwded_article')):
            repr_str = single_line_repr
        else:
            repr_str = f"{type_str}{INDENT_NEWLINE}" + INDENTED_JOIN.join(props)
            repr_str += ',' if props else ''
            repr_str += '\n)'

        if args.constantize:
            repr_str = INDENT + INDENT_NEWLINE.join(repr_str.split('\n'))
            return repr_str.replace(',,', ',').replace(',),', '),').replace(',),', '),')
        else:
            return repr_str


@dataclass(kw_only=True)
class CommunicationCfg(DocCfg):
    """
    Manual config is always required for MessengerLog author attribution. It's also often needed for Email
    files to handle the terrible OCR text that Congress provided which messes up a lot of the email headers.

    Attributes:
        is_fwded_article (bool, optional): `True` if this is a newspaper article someone fwded. Used to exclude articles from word counting.
        recipients (list[Name]): Who received the communication
        uncertain_recipient (str, optional): Optional explanation of why this recipient was attributed, but uncertainly
    """
    is_fwded_article: bool | None = None
    recipients: list[Name] = field(default_factory=list)
    uncertain_recipient: str | None = None

    @property
    def recipients_str(self) -> str:
        return ', '.join([r or UNKNOWN for r in self.recipients])

    @property
    def is_of_interest(self) -> bool | None:
        """Fwded articles are not interesting."""
        if self.is_fwded_article and not self.is_interesting:
            return False
        else:
            return super().is_of_interest

    def __post_init__(self):
        return super().__post_init__()

    def __repr__(self) -> str:
        return super().__repr__()


@dataclass(kw_only=True)
class EmailCfg(CommunicationCfg):
    """
    Attributes:
        actual_text (str, optional): In dire cases of broken OCR we just configure the body of the email as a string.
        fwded_text_after (str, optional): If set, any text after this is a fwd of an article or similar.
        has_uninteresting_ccs (bool): If `True` this email's CC: recipients will be marked as 'uninteresting'.
        has_uninteresting_bccs (bool): If `True` this email's BCC: recipients will be marked as 'uninteresting'.
        subject (str, optional): Subject line.
    """
    actual_text: str | None = None
    fwded_text_after: str | None = None
    has_uninteresting_ccs: bool = False
    has_uninteresting_bccs: bool = False
    subject: str | None = None

    # This is necessary because for some dumb reason @dataclass(repr=False) doesn't cut it
    def __repr__(self) -> str:
        return super().__repr__()


@dataclass(kw_only=True)
class TextCfg(CommunicationCfg):
    # This is necessary because for some dumb reason @dataclass(repr=False) doesn't cut it
    def __repr__(self) -> str:
        return super().__repr__()
