import json
import re
from copy import deepcopy
from dataclasses import Field, asdict, dataclass, field, fields
from datetime import datetime
from typing import Generator, Literal, Self

from dateutil.parser import parse

from epstein_files.util.constant.names import *
from epstein_files.util.constant.strings import *
from epstein_files.util.env import args
from epstein_files.util.helpers.data_helpers import without_falsey
from epstein_files.util.helpers.string_helper import optional_prefix, quote

DuplicateType = Literal['bounced', 'earlier', 'quoted', 'redacted', 'same']
Metadata = dict[str, bool | datetime | int | str | list[str | None] |dict[str, bool | str]]

# Misc
MAX_LINE_LENGTH = 135
REPUTATION_MGMT = f'{REPUTATION} management'
SAME = 'same'


UNINTERESTING_CATEGORIES = [
    ACADEMIA,
    ARTICLE,
    ARTS,
    BOOK,
    CONFERENCE,
    JUNK,
    POLITICS,
    # SKYPE_LOG,
    # TWEET,
]

INTERESTING_AUTHORS = [
    EDWARD_JAY_EPSTEIN,
    EHUD_BARAK,
    JOI_ITO,
    NOAM_CHOMSKY,
    MICHAEL_WOLFF,
    SVETLANA_POZHIDAEVA,
]

UNINTERESTING_AUTHORS = [
    GORDON_GETTY,
    NOBEL_CHARITABLE_TRUST,
    PALM_BEACH_CODE_ENFORCEMENT,
    PALM_BEACH_WATER_COMMITTEE,
    UN_GENERAL_ASSEMBLY,
]

# OtherFiles whose descriptions/info match these prefixes are not displayed unless --all-other-files is used
UNINTERESTING_PREFIXES = [
    'article about',
    CVRA,
    f"{HARVARD} Econ",
    HARVARD_POETRY,
    JASTA,
    LEXIS_NEXIS,
    PALM_BEACH_TSV,
    'US Office',
]

DUPE_TYPE_STRS: dict[DuplicateType, str] = {
    'bounced': 'a bounced copy of',
    'earlier': 'an earlier draft of',
    'quoted': 'quoted in full in',
    'redacted': 'a redacted version of',
    SAME: 'the same as',
}

# only used to order fields in metadtaa and repr()
FIELD_SORT_KEY = {
    'id': 'a',
    'author': 'aa',
    'comment': 'zz',
    'duplicate_ids': 'dup',
    'duplicate_of_id': 'dupe',
    'recipients': 'aaa',
}

FINANCIAL_REPORTS_AUTHORS = [
    BOFA_MERRILL,
    DEUTSCHE_BANK,
    ELECTRON_CAPITAL_PARTNERS,
    GOLDMAN_INVESTMENT_MGMT,
    'Invesco',
    JP_MORGAN,
    'Morgan Stanley',
    'S&P',
]

# Fields like timestamp and author are better added from the Document object
NON_METADATA_FIELDS = [
    'actual_text',
    'id',
    'is_synthetic',
    'replace_text_with',
]

# Categories where we want to include the category name in the description
DESCRIPTIVE_CATEGORIES = set([
    BOOK,
    REPUTATION,
    SKYPE_LOG,
    TWEET,
])


@dataclass(kw_only=True)
class DocCfg:
    """
    Encapsulates info about files that needs to be manually configured because it cannot be programmatically inferred.

    Attributes:
        id (str): ID of file
        author (Name): Author of the document (if any)
        author_reason (str, optional): Optional explanation of why we are sure this email can be attributed to this author
        author_uncertain_msg(str | bool, optional): Like setting `author_reason` but `is_attribution_uncertain` will be False
        category (str, optional): Type of file
        date (str | None): Parsed to a datetime by timestamp() if it exists
        dupe_type (DuplicateType | None): The type of duplicate this file is or its 'duplicate_ids' are
        duplicate_ids (list[str]): IDs of *other* documents that are dupes of this document
        duplicate_of_id (str | None): If this is a dupe the ID of the duplicated file. This file will be suppressed
        is_interesting (bool | None): Override other considerations and always consider this file interesting (or not)
        is_synthetic (bool): True if this config was generated by the duplicate_cfgs() method
        replace_text_with (bool): True if `description` should replace body of the document when printing.
        truncate_to (int, optional): Number of characters to truncate this email to when displayed.
    """
    id: str
    attached_to_email_id: str | None = None
    author: Name = None
    author_reason: str = ''
    author_uncertain: bool | str = ''
    category: str = ''
    comment: str = ''
    date: str | None = None
    description: str = ''
    dupe_type: DuplicateType | None = None
    duplicate_ids: list[str] = field(default_factory=list)
    duplicate_of_id: str | None = None
    is_interesting: bool | None = None
    is_synthetic: bool = False
    replace_text_with: str = ''
    truncate_to: int | None = None

    @property
    def author_str(self) -> str:
        return self.author or ''

    @property
    def complete_description(self) -> str:
        """String that summarizes what is known about this document."""
        has_any_info = bool(self.description or self.author)
        preamble = self.category if self.category in DESCRIPTIVE_CATEGORIES else ''
        preamble = preamble if (has_any_info or preamble) else self.category
        author_separator = ' '
        description = ''

        if self.category in [ACADEMIA, BOOK]:
            description = optional_prefix(quote(self.description), self.author, ' by ')  # note reversed args
        if self.category == SKYPE_LOG:
            author_separator = " of conversation with "
        elif self.category == REPUTATION:
            author_separator = ": "
        elif self.category == TWEET:
            author_separator = " by "
        elif self.category == FINANCE and self.author in FINANCIAL_REPORTS_AUTHORS:
            author_separator = ' report: '
        elif self.category == LEGAL and 'v.' in self.author_str:
            author_separator = ': '

        author_and_description = description or optional_prefix(self.author, self.description, author_separator)

        if self.attached_to_email_id:
            description = optional_prefix(description, f"attached to email {self.attached_to_email_id}")

        return optional_prefix(preamble, author_and_description)

    @property
    def is_attribution_uncertain(self) -> bool:
        return bool(self.author_uncertain)

    @property
    def is_of_interest(self) -> bool | None:
        """
        Self.is_interesting` value takes precedence. After that applies rules below.
        Returns None (not False!) if there's no firm decision.

                   "+": interesting / "-": uninteresting

          + interesting: 'crypto' category
          + interesting: INTERESTING_AUTHORS
          + interesting: having no author/description *if* HOUSE_OVERSIGHT
          - uninteresting: duplicates
          - uninteresting: descriptions with UNINTERESTING_PREFIXES
          - uninteresting: UNINTERESTING_CATEGORIES
          - uninteresting: 'finance' with any author is uninteresting
        """
        if self.duplicate_of_id:
            return False
        elif self.is_interesting is not None:
            return self.is_interesting
        elif self.author in INTERESTING_AUTHORS:
            return True

        # Category checks
        if self.category == CRYPTO:
            return True
        elif self.category == FINANCE and self.author is not None:
            return False
        elif self.category in UNINTERESTING_CATEGORIES:
            return False
        elif any (self.description.startswith(pfx) for pfx in UNINTERESTING_PREFIXES):
            return False

        return None

    @property
    def metadata(self) -> Metadata:
        metadata = {k: v for k, v in asdict(self).items() if k not in NON_METADATA_FIELDS and v}

        if self.is_interesting is False:
            metadata['is_interesting'] = False

        return metadata

    @property
    def timestamp(self) -> datetime | None:
        if self.date:
            return parse(self.date)

    def __post_init__(self):
        self.category = self.category.strip().lower()

        if self.category in [ARTS, POLITICS]:
            self.category = self.category.removesuffix('s')

        if self.duplicate_of_id or self.duplicate_ids:
            self.dupe_type = self.dupe_type or SAME

        if self.author_uncertain and isinstance(self.author_uncertain, str):
            self.author_reason = self.author_uncertain

    def duplicate_cfgs(self) -> Generator[Self, None, None]:
        """Create synthetic `DocCfg` objects that set the 'duplicate_of_id' field to point back to this object."""
        for id in self.duplicate_ids:
            dupe_cfg = deepcopy(self)
            dupe_cfg.id = id
            dupe_cfg.duplicate_of_id = self.id
            dupe_cfg.duplicate_ids = []
            dupe_cfg.dupe_type = self.dupe_type
            dupe_cfg.is_synthetic = True
            yield dupe_cfg

    def _props_strs(self) -> list[str]:
        props = []
        add_prop = lambda f, value: props.append(f"{f.name}={value}")

        for _field in sorted(fields(self), key=lambda f: FIELD_SORT_KEY.get(f.name, f.name)):
            value = getattr(self, _field.name)

            if _field.name in ['actual_text', 'is_fwded_article', 'is_interesting']:  # fields can be False or None or ''
                if value is not None:
                    add_prop(_field, json.dumps(value))
            elif not value or _field.name == 'dupe_type' and value == 'same':
                continue
            elif _field.name == AUTHOR:
                add_prop(_field, constantize_name(str(value)) if args.constantize else f"'{value}'")
            elif _field.name == 'recipients':
                recipients_str = str([constantize_name(r) if (args.constantize and r) else r for r in value])
                add_prop(_field, recipients_str.replace("'", '') if args.constantize else recipients_str)
            elif isinstance(value, str):
                if "'" in value:
                    value = '"' + value.replace('"', r'\"') + '"'
                else:
                    value = "'" + value.replace("'", r'\'') + "'"

                add_prop(_field, value)
            else:
                add_prop(_field, str(value))

        return props

    def __repr__(self) -> str:
        props = self._props_strs()
        type_str = f"{type(self).__name__}("
        single_line_repr = type_str + ', '.join(props) + f')'

        if len(single_line_repr) < MAX_LINE_LENGTH or (self.comment and getattr(self, 'is_fwded_article')):
            repr_str = single_line_repr
        else:
            repr_str = f"{type_str}{INDENT_NEWLINE}" + INDENTED_JOIN.join(props)
            repr_str += ',' if props else ''
            repr_str += '\n)'

        if args.constantize:
            repr_str = INDENT + INDENT_NEWLINE.join(repr_str.split('\n'))
            return repr_str.replace(',,', ',').replace(',),', '),').replace(',),', '),')
        else:
            return repr_str


@dataclass(kw_only=True)
class CommunicationCfg(DocCfg):
    """
    Manual config is always required for MessengerLog author attribution. It's also often needed for Email
    files to handle the terrible OCR text that Congress provided which messes up a lot of the email headers.

    Attributes:
        uncertain_recipient (str, optional): Optional explanation of why this recipient was attributed, but uncertainly
    """
    uncertain_recipient: str | None = None

    def __post_init__(self):
        return super().__post_init__()

    def __repr__(self) -> str:
        return super().__repr__()


@dataclass(kw_only=True)
class EmailCfg(CommunicationCfg):
    """
    Attributes:
        actual_text (str, optional): In dire cases of broken OCR we just configure the body of the email as a string.
        fwded_text_after (str, optional): If set, any text after this is a fwd of an article or similar.
        has_uninteresting_ccs (bool): If `True` this email's CC: recipients will be marked as 'uninteresting'.
        has_uninteresting_bccs (bool): If `True` this email's BCC: recipients will be marked as 'uninteresting'.
        is_fwded_article (bool, optional): `True` if this is a newspaper article someone fwded. Used to exclude articles from word counting.
        recipients (list[Name]): Who received the email.
        subject (str, optional): Subject line.
    """
    actual_text: str | None = None
    fwded_text_after: str | None = None
    has_uninteresting_ccs: bool = False
    has_uninteresting_bccs: bool = False
    is_fwded_article: bool | None = None
    recipients: list[Name] = field(default_factory=list)
    subject: str | None = None

    # This is necessary because for some dumb reason @dataclass(repr=False) doesn't cut it
    def __repr__(self) -> str:
        return super().__repr__()


@dataclass(kw_only=True)
class TextCfg(CommunicationCfg):
    # This is necessary because for some dumb reason @dataclass(repr=False) doesn't cut it
    def __repr__(self) -> str:
        return super().__repr__()
