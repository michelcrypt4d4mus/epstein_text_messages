import re
from copy import deepcopy
from dataclasses import Field, asdict, dataclass, field, fields
from datetime import datetime
from typing import Generator, Literal

from dateutil.parser import parse

from epstein_files.util.constant.names import constantize_name
from epstein_files.util.constant.strings import AUTHOR

DuplicateType = Literal['same', 'earlier', 'quoted', 'redacted']

INDENT = '    '
INDENT_NEWLINE = f'\n{INDENT}'
INDENTED_JOIN = f',{INDENT_NEWLINE}'
CONSTANTIZE_NAMES = False  # A flag set to True that causes repr() of these classes to return strings of usable code
MAX_LINE_LENGTH = 250

REASON_MAPPING: dict[DuplicateType, str] = {
    'earlier': 'earlier draft of',
    'quoted': 'quoted in full in',
    'redacted': 'redacted version of',
    'same': 'the same as',
}

FIELD_SORT_KEY = {
    'id': 'a',
    'author': 'aa',
    'attribution_reason': 'zz',
}


@dataclass(kw_only=True)
class FileCfg:
    """Convenience class that encapsulates configuring info about files that need to be manually configured.

    Attributes:
        id (str): ID of file
        author (str | None): Author of the document (if any)
        date (str | None): If passed will be immediated parsed into the 'timestamp' field
        dupe_of_id (str | None): If this is a dupe the ID of the duplicated file. This file will be suppressed.
        dupe_type (str | None): Redacted, quoted, etc.
        duplicate_ids (list[str]): Inverse of 'dupe_of_id' - this file will NOT be suppressed but 'duplicate_ids' will be.
        autduplicate_typehor (DuplicateType | None): The type of duplicate this file is
        timestamp (datetime | None): Time this email was sent, file was created, article published, etc.
        was_generated (bool): True if this object was generated by the duplicate_cfgs() method
    """
    id: str
    author: str | None = None
    date: str | None = None
    description: str | None = None
    dupe_of_id: str | None = None
    dupe_type: DuplicateType | None = None
    duplicate_ids: list[str] = field(default_factory=list)
    timestamp: datetime | None = None
    was_generated: bool = False  # True if this object was generated by duplicate_cfgs()

    def __post_init__(self):
        if self.dupe_of_id:
            self.dupe_type = self.dupe_type or 'same'

        if self.date:
            self.timestamp = parse(self.date)

    def duplicate_reason(self) -> str | None:
        if self.dupe_type is not None:
            return REASON_MAPPING[self.dupe_type]

    def duplicate_cfgs(self) -> Generator['FileCfg', None, None]:
        for id in self.duplicate_ids:
            dupe_cfg = deepcopy(self)
            dupe_cfg.id = id
            dupe_cfg.dupe_of_id = self.id
            dupe_cfg.dupe_type = self.dupe_type or 'same'
            dupe_cfg.was_generated = True
            yield dupe_cfg

    def non_null_field_names(self) -> list[str]:
        return [f.name for f in self.sorted_fields() if getattr(self, f.name)]

    def sorted_fields(self) -> list[Field]:
        return sorted(fields(self), key=lambda f: FIELD_SORT_KEY.get(f.name, f.name))

    def _props_strs(self) -> list[str]:
        props = []
        add_prop = lambda f, value: props.append(f"{f.name}={value}")

        for _field in self.sorted_fields():
            value = getattr(self, _field.name)

            if value is None or value is False or (isinstance(value, list) and len(value) == 0):
                continue
            elif _field.name == AUTHOR:
                add_prop(_field, constantize_name(str(value)) if CONSTANTIZE_NAMES else f"'{value}'")
            elif _field.name == 'recipients' and isinstance(value, list):
                recipients_str = str([constantize_name(r) if (CONSTANTIZE_NAMES and r) else r for r in value])
                add_prop(_field, recipients_str.replace("'", '') if CONSTANTIZE_NAMES else recipients_str)
            elif isinstance(value, datetime):
                value_str = re.sub(' 00:00:00', '', str(value))
                add_prop(_field, f"parse('{value_str}')" if CONSTANTIZE_NAMES else f"'{value}'")
            elif _field.name == 'description':
                add_prop(_field, value.strip())
            elif isinstance(value, str):
                if "'" in value:
                    value = '"' + value.replace('"', r'\"') + '"'
                else:
                    value = "'" + value.replace("'", r'\'') + "'"

                add_prop(_field, value)
            else:
                add_prop(_field, str(value))

        return props

    def __eq__(self, other: 'FileCfg') -> bool:
        """Return True if everything matches other than the two 'dupe_' fields ('duplicate_ids' is compared)."""
        for _field in self.sorted_fields():
            if _field.name == 'id' or _field.name.startswith('dupe'):
                continue
            elif getattr(self, _field.name) != getattr(other, _field.name):
                return False

        return True

    def __repr__(self) -> str:
        props = self._props_strs()
        type_str = f"{type(self).__name__}("
        single_line_repr = type_str + ', '.join(props) + f')'

        if (len(single_line_repr) < MAX_LINE_LENGTH or self.non_null_field_names() == ['id', 'description']) and '#' not in (self.description or ''):
            repr_str = single_line_repr
        else:
            repr_str = f"{type_str}{INDENT_NEWLINE}" + INDENTED_JOIN.join(props)
            repr_str += ',' if props else ''
            repr_str += '\n)'

        if CONSTANTIZE_NAMES:
            repr_str = INDENT + INDENT_NEWLINE.join(repr_str.split('\n'))
            return repr_str.replace(',,', ',').replace(',),', '),').replace(',),', '),')
        else:
            return repr_str


@dataclass(kw_only=True)
class MessageCfg(FileCfg):
    """
    Convenience class to unite various configured properties for a given Communication file.
    Manual config is always required for MessengerLog author attribution. It's also often needed for Email
    files to handle the terrible OCR text that Congress provided which messes up a lot of the email headers.

    Attributes:
        actual_text (str | None): In dire cases of broken OCR we just configure the body of the email as a string.
        attribution_reason (str | None): Optional explanation of why this email was attributed to this author.
        is_author_uncertain (bool): True if we have a good idea of who the author is but are not 100% certain
        is_fwded_article (bool): True if this is a newspaper article someone fwded. Used to exclude articles from word counting.
        recipients (list[str | None]): Who received the email
    """
    actual_text: str | None = None  # Override for the Email._actual_text() method for particularly broken emails
    attribution_reason: str | None = None
    is_author_uncertain: bool = False
    is_fwded_article: bool = False
    recipients: list[str | None] = field(default_factory=list)

    def __eq__(self, other: 'FileCfg') -> bool:
        return super().__eq__(other)

    def __repr__(self) -> str:
        return super().__repr__()

    @classmethod
    def from_file_cfg(cls, cfg: FileCfg) -> 'MessageCfg':
        return cls(**asdict(cfg))
